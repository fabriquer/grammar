:source-highlighter: pygments
:toc: right
:toclevels: 3

= The Fabrique build language

== Motivation

== Grammatical elements

=== Values

A Fabrique file is made up of [optionally-]named values.

.Example
[source,fabrique]
----
source_files = files(a.cc b.cc);
count:int = source_files.length();

object_files = compile(source_files);
executable = link(object_files);
----

.Grammar
[source,antlr]
----
file		: (values+=value)* EOF;
value		: (name=Identifier (':' type)* '=')? expression ';';
----

.Semantics
Most values bind a name (which must be a <<Identifiers,legal identifier>>)
to the result of evaluating an <<Expressions,expression>>.
It's also possible to simply use an expression without naming it, but that's
only really useful for expressions that cause side effects (e.g., declaring
a build step without giving it an explicit name).
Values are like variables in many languages, but with a few key aspects
from functional programming:

1. values are immutable, so there is no distinction between declaration and
   assignment;
2. a value's type may be specified explicitly or _inferred_ by Fabrique:
   a. all expressions (on the RHS) evaluate to a value with a type, so that
      type can be found when the build is configured;
   b. if an explicit type is given, Fabrique will check that the expression
      evaluates to a <<Subtypes,subtype of the explicit type>>;
3. value names may not be redefined within a scope;

Otherwise, values share some characteristics with statements in other
curly-brace languages like C and Java:

1. values are terminated by a semicolon;
2. if the value has a name, it must be followed by an equals sign.


=== Expressions

Almost everything in Fabrique is an expression that can be evaluated.


==== Build actions

A _build action_ represents a step that transforms input file(s) to output
file(s).
Common build actions include compiling source files, linking libraries and
executables and generating code (e.g., with `rpcgen` and `yacc`).
Actions defined in Fabrique source files execute shell commands with string
substitution (e.g., `'${cc} ${cflags} -c ${src} -o ${obj}'`); these commands
are executed at build time (rather than compile time).

.Examples
[source, fab]
----

cc = action('${cc} ${flags} -c ${src} -o ${obj}', description = 'Compiling ${src}'
	<= src: file[in], obj: file[out], flags: list[string] = []);

obj:file = cc(src_file);
----

An action contains:

- a command to run,
- [optional] arguments to the action itself (e.g., `description`) and
- parameters that invocations of the action need to provide.

Actions have a <<Function types,function type>>,
e.g., `(file[in])=>file[out]`, and can be <<Calls,called>> like functions.

The command to execute can include `${varname}`-style substitution patterns.
These substitutions can capture values from the parameters required by the
action, or else from the arguments provided to the action, or if not found
there, captured from the script that the action is defined in
(useful for selecting tools, e.g., `${cc}`).

Arguments to the action (after the command) must be keyword arguments
(see <<Calls>> for more details).
A `description` argument can be used to customize build log output
(e.g., `'Compiling ${src}'`).
Other arguments are made available for substitution into the command.

Action parameters can be of any defined <<Types,type>>.
Parameters of `file` type should specify whether the file in question is an
input to the rule (`file[in]`) or an output (`file[out]`).
This is critical for calculating the graph of build dependencies;
it is an error to omit the `in` or `out` tag.

.Grammar
[source, antlr]
----
buildAction
	: 'action' '(' command=expression
		(',' keywordArguments)?
		('<-' parameters)?
		')'
	;
----


==== Calls

Values of function type (including both <<Build actions,build actions>>
and <<Functions,functions>>) can be _called_ using a syntax that looks like
a lot of languages: with comma-separated arguments inside of parentheses.

.Examples
[source, fab]
----
noArguments();
positionalArguments(1, 2, 'hello', true);
keywordArguments(what='hello', who = 'world');
mixedArguments(1, 2, x=3);
----

Arguments may be _positional_ (parameter name unspecified) or
_keyword_ (parameter name specified).
Positional arguments, if present, must come first â€” otherwise it would be
difficult to tell which parameter you intend each argument to be passed to.
It is permissible to use an extra comma at the end of the argument list;
this can help reduce the sizes of diffs when parameters and arguments are
added or removed.

.Grammar
[source, antlr]
----
// Anything with a function type can be called
call	: term '(' arguments? ')' ;

arguments
	: positionalArguments ',' keywordArguments
	| positionalArguments
	| keywordArguments
	;

keywordArgument	: Identifier '=' expression ;
keywordArguments: (args+=keywordArgument (',' args+=keywordArgument)* ','?) ;

positionalArguments	: expression (',' expression)* ','? ;
----


==== Compound expressions

A compound expression is a braced list of values followed by an expression.
The values describe intermediate state that can be used by the final
"result" expression.

.Example
[source, fab]
----
{
	src = file(basename + '.c');
	obj = compile(src);
	binary = link(obj);

	binary
}
----

Compound expressions can help clarify the meaning of expressions like
<<Conditionals,conditionals>> by adding braces.
They also constrain the scope of intermediate variables, which can also help
with clarity of expression.

.Grammar
[source, antlr]
----
// Zero or more value definitions and a result
compoundExpr	: '{' (values+=value)* result=expression '}' ;
----


==== Conditionals

Rather than an `if` statement, Fabrique has a conditional `if`
_expression_.
This functions like the ternary operator in C, but is hopefully a bit more
readable:

[source,fab]
----
like_an_if_statement = if (y > 0) { y } else { -y };
----

Unlike other popular languages, the parentheses around the condition
(making it a <<Parenthetical expressions,parenthetical expression>>)
and the braces around the "then" and "else" clauses
(making them <<Compound expressions,compound expressions>>)
are entirely optional:

[source,fab]
----
more_succinct = if y > 0 y else -y;
----

Whether or not to use the extra punctuation is a question of clarity and style.

.Grammar
[source,antlr]
----
conditional
	: 'if'
	  condition=expression
	  thenClause=expression
	  'else'
	  elseClause=expression
	;
----


==== Field references

<<Records>> contain fields, which are accessed using the dot (`.`) operator.

.Examples
[source, fab]
----
# Access a single field:
simple = foo.bar;

# Access a field within a field (within a field, within a field, ...):
nested = foo.bar.baz;

# Slightly more complicated things:
complex = (if something foo else bar).baz.wibble;

veryComplex = {
	x = record { foo = 42 };
	y = record { bar = x };

	y
}.bar.foo;
----


The base of a field reference (the record containing the fields) must be a
<<Terms,term>>, but that includes compound expressions and
parenthetical expressions.
Using one of those constructs, you can construct expressions that are quite
sophisticated.
However, good style would suggest that you keep visual complexity under control.

.Grammar
[source, antlr]
----
// Access a field within a record
fieldReference
	: term '.' Identifier
	| fieldReference '.' Identifier     // explicitly left-recursive
	;
----


==== Parenthetical expressions

An expression enclosed in parentheses is treated as a <<Terms,_term_>>
and can therefore appear in places that a more general expression expression
cannot.
It is also evaluated before subexpressions that are not inside of the
parentheses.

.Examples
[source, fab]
----
# Specifying an order of operations:
x = p and (q or r);

# Choose which function we want to call:
y = (if useF f else g)(x);

# Without parentheses, g(x) is evaluated before the if condition:
bad = if useF f else g(x);
----

Just like every other language, Fabrique has an order of operations for its
operators, and parentheses can be used to override that order.
In the example above, the expression for `x` will only be true if `p` is true;
without parentheses, `r` alone would be sufficient to make `x` true.

Parentheses are also helpful when we want to use an expression inside of an
expression that only works with terms.
For example, a <<Calls,call>> or <<Field references,field reference>>
requires its target (the function to call or the record to look in) to be
a term.
The example code above shows how we can use an expression like a
<<Conditionals,conditional>> to choose which function we want to call,
then use that conditional within parentheses to actually specifify the
call target.


.Grammar
[source, antlr]
----
parentheticalExpression	: '(' expression ')' ;
----


=== TODO

==== Binary operators

////
binaryOperation	: logicalOperation | comparison | sum ;

logicalOperation: lhs=comparison LogicOp rhs=logicalOperation ;
LogicOp		: 'and' | 'or' | 'xor' ;

logicOrCompare	: logicalOperation | comparison ;

comparison	: lhs=sumOrTerm CompareOp rhs=sumOrTerm ;
CompareOp	: '<' | '<=' | '>' | '>=' | '==' | '!=' ;

sumOrTerm	: sum | term ;

sum		: lhs=term ('+' | '::' | '.+') rhs=sumOrTerm ;
////


==== Field queries

////
/**
 * A field query lets us provide a default value for a record field that may
 * or may not exist.
 *
 * ```fab
 * debug = args.debug ? false;
 * ```
 */
fieldQuery	: base=term '.' field=Identifier '?' defaultValue=expression ;
////

==== Files

////
	/**
	 * A file in the described build, with a name and, optionally, arguments.
	 *
	 * Example:
	 * `file('foo.c', cflags = [ '-D' 'FOO' ])`
	 */
////

==== File lists

////
	/**
	 * File lists can include raw filenames as well as embedded file declarations,
	 * optionally followed by arguments.
	 *
	 * Example:
	 * ```
	 * files(
	 *   foo.c
	 *   bar.c
	 *   file('baz.c', cflags = [])
	 *   ,
	 *   arg1 = 'hello', arg2 = 42
	 * )
	 * ```
	const Rule FileList =
		Keywords.Files
		>> Symbols.OpenParen
		>> *(File | Filename)
		>> -(Symbols.Comma >> KeywordArguments)
		>> Symbols.CloseParen
		;
	 */
////


==== Foreach

////
/**
 * A foreach loop transforms a sequence of values into another sequence,
 * possibly of different type.
 *
 * ```fab
 * y = foreach x <- [ 1 2 3 ] {
 * 	x + 1
 * };
 * ```
 *
 * Or, equivalently:
 *
 * ```fab
 * y = foreach x <- [ 1 2 3 ]
 * 	x + 1;
 * ```
 */
foreach
	: 'foreach' Identifier (':' type)? '<-' src=expression body=expression
	;
////

==== Functions

////
	/**
	 * A function is a fairly conventional closure that can capture values
	 * from its surrounding scope.
	 *
	 * ```fab
	 * f = function(x:int, y:list[string]): int
	 * {
	 * 	x + 1
	 * };
	 * y = f(1);
	 * ```
	 *
	 * Or, equivalently:
	 *
	 * ```fab
	 * y = (function(x:int, y:list[string]) x + 1)(1);
	 * ```
	 */
/**
 * A function, much like in other languages, takes parameters and may return
 * a value.
 *
 * ```fab
 * compile = function(srcs:list[file], common_flags:list[string] = [],
 *                    deps:list[file[in]] = []): list[file]
 * {
 *     foreach src <- srcs {
 *         obj = src + '.o';
 *         flags = (src.cxxflags ? common_flags) + default_flags.object;
 * 
 *         compile_one(src, obj, flags, deps);
 *         obj
 *     }
 * };
 * ```
 */
function	: 'function' '(' parameters ')' (':' type)? body=expression ;

/*
function:
	functiondecl '(' parameterList ')' ':' type expression
	{
		SourceRange begin = Take(Parser::ParseToken($1))->source();
		auto params = Take(NodeVec<Parameter>($3));
		auto *retTy = $6.type;
		auto body = TakeNode<Expression>($7);
		SetOrDie($$, p->DefineFunction(begin, params, body, retTy));
	}
	|
	functiondecl '(' parameterList ')' expression
	{
		SourceRange begin = Take(Parser::ParseToken($1))->source();
		auto params = Take(NodeVec<Parameter>($3));
		auto body = TakeNode<Expression>($5);
		SetOrDie($$, p->DefineFunction(begin, params, body));
	}
	;
*/

/**
 * Positional arguments are matched to parameters by order.
 *
 * ```fab
 * f(1, 2.0)
 * ```
 */

	/**
	 * Keyword arguments are matched to parameters by explicit name.
	 *
	 * ```fab
	 * f(a = 1, b = 2.0)
	 * ```
	 */

	/**
	 * Named arguments must always come after unnamed (positional) arguments.
	 *
	 * ```fab
	 * f(x, y, z);
	 * f(a = x, b = y, c = z);
	 * f(x, c = z, b = y);
	 * ```
	 */

	/**
	 * Actions and functions are both callable.
	 *
	 * ```fab
	 * f = function(x:int) x + 1;
	 * a = action(...);
	 *
	 * result = a(version = f(42));
	 * ```
	 */

parameters	: (parameter (',' parameter)*)? ;
parameter	: Identifier ':' type ('=' expression)? ;
////


////

/*
		// Match calls after things that look vaguely call-like such as files:
		| Call

		// Put identifier references after keywords so that
		// we don't match keywords as identifiers:
		| NameReference
		;
 */
////


==== Literals

////
literal
	: Boolean
	| Integer
	| String
	;

Boolean	: 'true' | 'false' ;
Integer	: [0-9]+ ;
String
	: '\'' .*? '\''
	| '"' .*? '"'
	;
////


==== Lists

////
/**
 * Lists are containers for like values and do not use comma separators.
 * The type of the list is taken to be "list of the supertype of all of the
 * list's elements".
 *
 * Example:
 * ```
 * x:int = 42;
 * y:special_int = some_special_kind_of_int();
 *
 * [ 1 2 3 x y ]   # the type of this is list[int]
 * ```
 */
list		: '[' (values+=expression)* ']' ;
////

==== Records

==== Terms

==== Unary operations

////
unaryOperation	: ('not' | '-' | '+') expression ;
////


=== Types

==== Simple types

==== Parametric types

==== Record types

==== Function types

==== Subtypes

////
/**
 * There are four syntaxes for naming types:
 *
 *  - function types: `(type1, type2) => resultType`
 *  - record types: `record[field1:type2, field2:type2]`
 *  - parametric types: `simpleName[typeArg1, typeArg2]`
 *  - simple types: `int`, `string`, `foo`, etc.
 */
type
	: functionType
	| recordType
	| parametricType
	| simpleType
	;

functionType	: '(' type_list ')' '=>' type ;
recordType	: 'record' '[' (fieldType (',' fieldType)*)? ','? ']' ;
fieldType	: Identifier ':' type ;
parametricType	: simpleType '[' type_list ']' ;
simpleType	: Identifier ;

type_list : type (',' type)* ','? ;

////


=== Identifiers

.Grammar
[source,antlr]
Identifier	: [a-zA-Z] [a-zA-Z0-9_]*;


=== Comments and whitespace

Comments and whitespace look much like they do in shell scripts:
single-line comments start with a `#` character, there are no multi-line
comments and spaces, tabs and newlines are all ignored.

.Grammar
[source,antlr]
----
Comment		: '#' ~[\r\n]* -> skip;
WS		: [ \t\r\n]+ -> skip;
----
